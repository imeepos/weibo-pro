# RxGraph 应用场景与实用案例

## 核心应用场景

RxGraph 是一个**可视化的响应式数据流编排系统**，将 RxJS 的强大能力封装为可拖拽的节点图。适用于需要处理**异步数据流、事件驱动、实时计算**的场景。

### 目标用户
- 需要快速搭建数据管道的开发者
- 希望可视化调试复杂异步逻辑的工程师
- 构建低代码/无代码平台的架构师
- 实时数据处理系统的设计者

---

## 实用案例集

### 1. 实时搜索建议（防抖 + 取消旧请求）

**场景**：用户在搜索框输入时，实时显示搜索建议，避免频繁请求。

**流图设计**：
```
[输入事件] → [提取value] → [防抖300ms] → [过滤空值] → [switchMap请求API] → [渲染结果]
```

**节点配置**：
- **fromEvent**: 监听 `#search-input` 的 `input` 事件
- **map**: `x.target.value` 提取输入值
- **debounceTime**: 300ms 防抖
- **filter**: `x.length > 2` 过滤少于3字符的输入
- **switchMap**: 调用 `searchAPI(x)`，自动取消旧请求
- **tap**: 渲染搜索建议到 DOM

**关键价值**：
- 自动取消过期请求，避免结果乱序
- 减少 API 调用次数（防抖）
- 可视化调试：观察每个节点的数据流动

---

### 2. 表单联动验证（多字段组合校验）

**场景**：注册表单中，密码和确认密码需要实时比对，邮箱需要异步验证唯一性。

**流图设计**：
```
[密码输入] ─┐
            ├→ [combineLatest] → [比对逻辑] → [显示错误]
[确认密码] ─┘

[邮箱输入] → [debounce] → [switchMap验证API] → [显示可用性]
```

**节点配置**：
- **combineLatest**: 组合密码和确认密码的最新值
- **map**: `pwd === confirm ? null : '密码不一致'`
- **distinctUntilChanged**: 避免重复渲染相同错误

**关键价值**：
- 声明式描述字段依赖关系
- 异步验证与同步验证统一处理
- 易于扩展新的验证规则

---

### 3. WebSocket 实时数据看板（背压控制）

**场景**：股票行情大屏，WebSocket 推送海量数据，需要节流显示。

**流图设计**：
```
[WebSocket] → [解析JSON] → [按股票代码分组] → [throttle 1s] → [更新图表]
```

**节点配置**：
- **webSocket**: 连接 `wss://stock-api.com`
- **map**: `JSON.parse(x.data)`
- **groupBy**: 按 `x.symbol` 分组
- **throttleTime**: 每秒最多更新一次
- **mergeMap**: 并发更新多个股票的图表

**关键价值**：
- 背压控制：防止渲染频率过高导致卡顿
- 分组处理：不同股票独立节流
- 自动重连：WebSocket 断线重连逻辑可封装为节点

---

### 4. 文件上传进度聚合（多文件并发）

**场景**：批量上传文件，显示总体进度和单个文件状态。

**流图设计**：
```
[文件列表] → [mergeMap并发上传] → [scan累加进度] → [更新进度条]
                ↓
            [单文件进度] → [显示列表]
```

**节点配置**：
- **from**: 将文件数组转为流
- **mergeMap**: 并发上传（`concurrency: 3`）
- **scan**: 累加已完成字节数 `(acc, curr) => acc + curr.loaded`
- **map**: 计算百分比 `loaded / total * 100`

**关键价值**：
- 控制并发数，避免浏览器连接数限制
- 实时聚合进度，无需手动管理状态
- 支持取消上传（unsubscribe）

---

### 5. 鼠标拖拽（事件组合）

**场景**：实现可拖拽的 DIV 元素。

**流图设计**：
```
[mousedown] → [switchMap] → [mousemove直到mouseup] → [计算位移] → [更新位置]
```

**节点配置**：
- **fromEvent**: 监听 `mousedown`
- **switchMap**: 切换到 `mousemove` 流
- **takeUntil**: 直到 `mouseup` 事件
- **map**: 计算 `{ x: e.clientX - startX, y: e.clientY - startY }`
- **tap**: 更新元素的 `transform`

**关键价值**：
- 自动处理事件订阅/取消
- 避免内存泄漏（takeUntil 自动清理）
- 逻辑清晰：拖拽 = mousedown → (mousemove until mouseup)

---

### 6. API 请求重试（指数退避）

**场景**：调用不稳定的第三方 API，失败时自动重试，间隔递增。

**流图设计**：
```
[触发请求] → [switchMap调用API] → [retryWhen] → [延迟策略] → [返回结果]
```

**节点配置**：
- **retryWhen**: 捕获错误流
- **mergeMap**: 延迟重试 `delay(2^attempt * 1000)`
- **take**: 最多重试 3 次
- **catchError**: 最终失败时返回默认值

**关键价值**：
- 声明式重试策略（指数退避、固定间隔等）
- 避免硬编码 setTimeout
- 可视化观察重试过程

---

### 7. 实时日志流过滤（多条件筛选）

**场景**：监控系统日志，用户可动态调整过滤条件（级别、关键词）。

**流图设计**：
```
[日志流] ─┐
          ├→ [withLatestFrom过滤条件] → [filter应用规则] → [显示日志]
[条件表单] ┘
```

**节点配置**：
- **webSocket**: 接收日志流
- **BehaviorSubject**: 存储当前过滤条件
- **withLatestFrom**: 每条日志携带最新过滤条件
- **filter**: `log.level >= condition.level && log.message.includes(condition.keyword)`

**关键价值**：
- 动态过滤：无需重启日志流
- 条件变化时立即生效
- 支持复杂过滤逻辑（正则、多字段组合）

---

### 8. 定时任务编排（cron + 依赖）

**场景**：每小时抓取数据 → 清洗 → 入库 → 发送报告，任务间有依赖。

**流图设计**：
```
[interval 1h] → [抓取数据] → [concatMap清洗] → [concatMap入库] → [发送邮件]
```

**节点配置**：
- **interval**: 3600000ms（1小时）
- **concatMap**: 保证任务顺序执行（前一个完成才开始下一个）
- **catchError**: 任一步骤失败时记录日志并跳过

**关键价值**：
- 声明式任务依赖（concatMap 保证顺序）
- 错误隔离：单次任务失败不影响下次执行
- 可视化监控：观察每个步骤的耗时

---

### 9. 多数据源聚合（API + 缓存 + 数据库）

**场景**：查询用户信息时，优先读缓存，缓存未命中则查数据库，最后调用 API。

**流图设计**：
```
[查询请求] → [先查缓存] → [catchError查数据库] → [catchError调用API] → [写入缓存] → [返回结果]
```

**节点配置**：
- **defer**: 惰性创建查询流
- **catchError**: 缓存未命中时切换到数据库流
- **tap**: 查询成功后写入缓存
- **shareReplay**: 多个订阅者共享结果

**关键价值**：
- 优雅的降级策略（缓存 → 数据库 → API）
- 自动缓存更新
- 避免重复查询（shareReplay）

---

### 10. 实时协作编辑（OT 算法）

**场景**：多人同时编辑文档，需要同步操作并解决冲突。

**流图设计**：
```
[本地编辑] ─┐
            ├→ [merge] → [OT转换] → [应用到文档] → [广播到其他用户]
[远程操作] ─┘
```

**节点配置**：
- **Subject**: 本地编辑操作流
- **webSocket**: 远程操作流
- **merge**: 合并本地和远程操作
- **scan**: 应用 OT 算法转换冲突操作
- **distinctUntilChanged**: 避免重复应用相同操作

**关键价值**：
- 统一处理本地和远程操作
- OT 算法封装为可复用节点
- 实时同步，无需轮询

---

### 11. 视频播放器控制（状态机）

**场景**：播放器有播放、暂停、缓冲、错误等状态，需要响应用户操作和网络事件。

**流图设计**：
```
[播放按钮] ─┐
[暂停按钮] ─┤
[网络事件] ─┼→ [merge] → [scan状态机] → [更新UI]
[错误事件] ─┘
```

**节点配置**：
- **merge**: 合并所有事件源
- **scan**: 状态机逻辑 `(state, event) => nextState(state, event)`
- **distinctUntilChanged**: 状态未变化时不触发 UI 更新
- **tap**: 根据状态执行副作用（播放/暂停视频）

**关键价值**：
- 声明式状态机（无需 switch-case）
- 所有事件统一处理
- 易于扩展新状态和事件

---

### 12. 数据管道 ETL（抽取-转换-加载）

**场景**：从 CSV 文件读取数据 → 清洗 → 转换格式 → 批量写入数据库。

**流图设计**：
```
[读取CSV] → [解析行] → [过滤无效行] → [map转换] → [bufferCount批量] → [concatMap入库]
```

**节点配置**：
- **from**: 读取文件流
- **map**: 解析 CSV 行为对象
- **filter**: 过滤空行和无效数据
- **map**: 转换字段格式（日期、数字等）
- **bufferCount**: 每 100 条批量插入
- **concatMap**: 顺序执行数据库插入

**关键价值**：
- 流式处理大文件（不占用大量内存）
- 批量插入提升性能
- 错误行跳过，不影响整体流程

---

### 13. 智能通知系统（规则引擎）

**场景**：监控系统指标，满足规则时发送通知（如 CPU > 80% 持续 5 分钟）。

**流图设计**：
```
[指标流] → [bufferTime 1min] → [map计算平均值] → [filter > 80%] → [bufferCount 5] → [发送告警]
```

**节点配置**：
- **interval**: 每秒采集 CPU 使用率
- **bufferTime**: 1 分钟窗口
- **map**: 计算平均值
- **filter**: 超过阈值
- **bufferCount**: 连续 5 次才触发
- **exhaustMap**: 发送通知（忽略重复告警）

**关键价值**：
- 时间窗口聚合（避免瞬时抖动）
- 连续触发条件（bufferCount）
- 防止告警风暴（exhaustMap）

---

## 总结

RxGraph 的核心价值在于：

1. **可视化调试**：复杂异步逻辑一目了然
2. **声明式编排**：用图代替代码，降低心智负担
3. **可复用节点**：操作符封装为积木，随意组合
4. **实时监控**：观察每个节点的数据流动和性能

适用领域：
- 实时数据处理（IoT、金融、监控）
- 复杂表单交互（联动、验证）
- 事件驱动系统（游戏、协作工具）
- 数据管道编排（ETL、爬虫）

每个案例都是一首关于数据流动的诗，节点是诗句，连接是韵律。
